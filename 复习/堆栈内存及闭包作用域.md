
#  JavaScript 底层三座大山


# 一. 堆栈内存及闭包作用域

## 1. js 数据类型及区别

> 变量：

所谓变量，就是一个保存数值的容器，也可以说是一个可读可写的内存对象。声明变量，就是表示在内存中开辟一个存放数值的空间。

> 基本数据类型(6种)：

String,Number,Boolean，null, undefined,Symbol;

null：表示定义了一个"空值"(注意不是空字符串)
undefined： 表示根本没有定义；

```
let obj = null
let obj2 = {}
let obj3 =""
let un
console.log(obj)  // null  
console.log(obj2)  //  {}  空对象
console.log(obj3)  //   空字符
console.log(un) // undefined

```
 **<font color='#B71A1A' size=3.5 >null 和undefined 存在的意义：JavaScript 是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道）， 所以这就要一个值来表示对某成员的 getter 是取不到值的。 </font>** 

> 引用数据类型：

 Object(一般的对象) Function（特殊的对象， 可以执行） Array（特殊的对象，数据有下标，内部数据是有序的）

> 基本数据类型和引用数据类型的区别：

值存放在栈内存中，占用内存的空间大小是固定的；如果给一个变量赋值，值的类型是基本数据类型时，该变量保存的是这个值本身。将该变量赋值给另一个变量时，则两个变量的指针都指向同一个值；

引用数据类型存放在堆内存中，如果一个变量赋值，值得类型是引用数据类型，也就是说这个值是一个对象，则该变量保存的是这个对象在堆内存中的地址，复制该变量时，则复制的是保存的对象在堆内存中的地址；

```
  let a =10;
  let b = a; // a， b变量的指针都指向 栈内存中保存的 10，并不是将a的值拷贝复制了  一份再赋值给b变量；
  b = 20 ; // b 变量的指针指向20 
  console.log(b)  // 20
  console.log(a)  // 10 

  let obj= {
      name :"jack"
  }
  let obj2 = obj;
  obj2.name = "rose"

  console.log(obj.name)  // rose
  console.log(obj2.name)  // rose  

  以上可以说明，obj 和obj2 保存的是对象在堆内存中的地址，指向的是同一个对象，操作的是同一个对象

```

> 什么是函数？

函数就是一个有名字的，包含一些语句的代码块，只有调用时才执行代码块中包含的代码；

> 什么是对象？

对象就是保存多个数据的容器，一个无序键值对的集合；


> 数据类型判断


## 2. js 堆栈内存的运行机制


栈内存： 1. 提供代码自上而下的执行；2. 存储基本数据类型；

堆内存： 存储引用数据类型；




## 3. 变量的提升机制

声明的变量，会被当前的执行上下文对象，进行预处理，添加为该执行上下文对象的属性；

## 4. 作用域和作用域链

**作用域：** 作用域就是一个块"地盘"，一个代码所在的区域，决定了变量可以被查找的范围； 它是静态的（相对于上下文对象），在**编写代码时就确定了；**

**分类：** 

1. 全局作用域；
2. 函数作用域；
3. 没有块作用域（**ES6 中有**）
<pre><code>
  if(true){
    var  a = 100 ;
}
 console.log(a);  // 打印出100 ； 可以看出没有块级作用域；
</code></pre>

**作用：** 隔离变量，不同作用域下同名变量不会有冲突；

**作用域与执行上下文：**

1. 全局作用域之外，每个函数都会创建自己的作用域，在定义时就确定，而不是执行函数时确定；**全局执行上下文**是在作用域确定后，js代码马上执行前创建；**函数执行上下文**是在**函数调用时，函数体代码执行之前创建**

2. 作用域是静态的，只要函数定义好了，就一直存在，且不会变化；**执行上下文**是动态的，函数调用时创建，函数调用结束时就被自动释放；

3. 联系：执行上下文环境从属于所在的作用域， 全局执行上下文环境从属于全局作用域，函数执行上下文环境从属于函数作用域；

4. **作用域是用来隔离变量， 执行上下文环境是为了对变量和函数的提升做好数据预处理。** 

##作用域链：

**多个上下级关系的作用域，就形成了作用域链。保证执行环境里有权访问的变量和函数是有序的**
**变量的查找规则：** 在当前作用域的执行上下文环境中查找，找到了就返回，没有就进入上一级的作用域的执行上下文环境中查找，以此类推，如果在最外层的作用域的执行上下文环境中还没找到，就报错；

**实例理解：**

<pre><code>
eg1: var  x = 10;
  function fn(){
    console.log(x);
}
function show(f){
  var x =20;
  f();
}

show(fn);  //  输出 10 ； 因为函数的作用域是在定义时就确定了， fn() 的上级作用域是全局作用域 ；

eg2:
 var fn = function(){
     console.log(fn);
}
fn() ;  //  输出函数 fn ; 现在函数内部找fn ,找不到，就去全局中找， 刚好全局中声明定义了 var fn ；

eg3:  var obj= {
          fn2: function(){
          console.log(fn2);
}
}
obj.fn2();  // 报错 ；fn2中没有fn2 ,外层的全局作用域的上下文执行环境中也没有fn2 ; 只有 var obj ；

</code></pre>



## 5. 闭包的作用： 保存/保护

> **定义**： 所谓闭包，就是可以访问其他函数作用域中变量的***函数***。内部函数访问外部函数中变量就是闭包的例子，那个内部函数就是闭包。

>**产生条件**：有函数的嵌套，并且内部函数引用了外部函数中的变量，闭包就产生了。并不是非得调用内部函数；
>
> **作用**： 1.延长了局部变量的生命周期，在外部函数执行完后，被引用的变量不被销毁；2. 在函数外部可以操作函数内部的局部变量；
>  

> **应用场景**： 1. 将一个函数作为另一个函数的返回值；2.将一个函数作为实参传给另一个函数调用（即回调函数）；3. 在自定义的js模块中

  向外暴露一个对象，该对象包含模块中定义的属性和方法； 
> 
>**缺点**：
>
>1.被引用的变量不能及时销毁，容易造成内存泄漏(内存溢出是指程序运行所需要的内存超出了剩余的内存空间。内存泄漏积累过多就会造成内存溢出)。
>
>2.只能取得包含函数中变量的最后一个值。（这是因为内部函数只是定义了，但并没有立即执行）
>
> **例子：** 用闭包实现循环打印数组的下标
> 
<pre>
<code>
 for(var i=0;i`<`arrayy.length;i++){
     (function(i){
        console.log(i);
})(i);
}
</code></pre>

**例子：** 自定义js 模块向外输出对象：

<pre><code>
  // module.js 

   function moudule(){
    let msg = "hello js" ；
    function a (){
     console.log(`执行a方法${msg}`);
}
    function b (){
     console.log(`执行b方法${msg}`);
}

  return {
      a: a,
      b:b
}
}

//   index.js 中
   import * from module.js

   let module = module();
       module.a(); // "执行a方法发hello.js"
       module.b(); //  "执行b方法发hello.js"


</code></pre>
**闭包的生命周期：** 让包含闭包的的函数对象成为垃圾对象，即引用外部变量的那个内部函数  `f= null` ; 	
**函数定义执行和函数执行是两回事。**

## 6. 执行上下文

1. 执行环境栈：浏览器执行代码时，会提供一个执行代码的环境，也就是开辟一个栈内存空间，这块空间叫做执行环境栈；

  **<font color='#B71A1A' size=3.5 >2. 执行上下文：指的是当前执行环境中的变量，函数声明，参数，作用域链,this 等信息； </font>** 


3. 全局执行上下文和函数执行上下文： 全局执行上下文只有一个，函数执行上下文在函数调用时，都会生成一个新的函数执行上下文； 

4. 执行上下文的组成：变量对象(VO),作用域链,this;

5. 变量对象：存储了上下文中定义的变量和函数声明。

6. 全局执行上下文中： 变量对象就是全局对象，在浏览器中，就是window 对象；
7. 函数执行上下文中： 变量对象(VO)就是当前活动对象(AO)

## 7. 回调函数

> 定义

回调函数就是将一个函数作为参数传给另一个函数的函数；

> 特点

主体函数执行完了再执行回调函数

> 作用

当我们想要任务1执行完后再执行任务2，我们把任务1放在a函数里，把任务2放在b函数里，把b函数作为a函数的回调函数， 这样就可以保证先执行任务1，再执行任务2

## 用代码证实js 是单线程，异步 ，同时如何解决异步带来的问题
js是单线程
    v1: js是单线程
    
    ```
        let first = function () {
            console.log("做数学作业")
        }
        let second = function () {
            console.log("做语文作业")
        }

        first();
        second();

       // 控制台打印： 做数学作业  ，做语文作业
  
       // 调换顺序
         second();
         first();
         // 控制台打印： 做语文作业, 做数学作业 
      ```
#### js 的异步

   v2  js 异步

   ```
        let first = function () {
            // 模拟一个异步任务
            setTimeout(() => {
                console.log("做数学作业")
            }, 1000)
        }
        let second = function () {
            console.log("做语文作业")
        }

        first();
        second();
        控制台打印： 做语文作业 ，做数学作业

    // 调换顺序
        second();
        first();
        控制台打印： 做语文作业 ，做数学作业

 ```       
小结：js 语言是单线程的，但是任务分为同步和异步，异步任务不会立即执行，遇到异步任务先跳过，把同步任务执行完了再执行异步任务

## 通过回调来解决异步带来的问题
```
        // v3  利用回调函数保证先执行first里的任务，再执行second里的任务；

        let first = function (callback) {
            setTimeout(() => {
                console.log("做数学作业")
                callback()
            }, 1000)
        }
        first(() => {
            console.log("做语文作业");
        })

```
### 

# 二. 面向对象(oop)和this 处理


## this

> 定义：this 是当前执行上下文中的一个属性，而执行上下文又是根据当前执行环境来创建的。所以this 也是由当前执行环境所决定的；

 2. 具体的指向: 

    1. 全局环境下: 指向window 对象,  在setTimeout 或 setInterval 这样的延

    2. 对象环境中:  指向该对象.

    3.  构造函数环境:  该构造函数的 实例对象.

    4. 事件对象:  在DOM 事件中使用this , this指向触发事件的DOM 元素本身       
          eg:     button.onclick = function(){
                console.log(this.innerHTML);  
                        }
    5.  回调函数中的this 也是指向window;

    6. 箭头函数中的this ;
     箭头函数没有自己的 this，当在内部使用了 this时，它会指向最近一层作用域内的 this ;



# 三. DOM/BOM 及事件处理机制