# JavaScript执行机制


> ## 1. JS 引擎(V8)

v8引擎主要由两部分组成： 内存堆（内存分配地址的地方）, 调用栈（代码执行的地方）

执行阶段： 将JavaScript 代码分为一块块的，可执行代码块进行执行。

目前有3类代码块： 函数代码块，全局代码块，eval() 代码块

```javascript
  
   var name = "jack"

   function say(name){
       console.log(name)
       function play(){
           console.log("paly")
       }
       play()
   }
   say(name)

```

拿上面的代码为例，执行过程： 上面的代码声明被存放在 内存堆中，当调用say 方法时， say方法就会被压入调用栈。 栈是一个基础的数据结构，遵循“先进后出”；
在代码块执行前，会创建一个执行上下文,作为代码块的基本执行环境；

前面提到过有3类代码块， 这3类代码块对应着3种执行上下文

> ## 2. 执行上下文

执行上下文分为两个阶段： 创建阶段和执行阶段 

执行上下文的创建阶段主要解决以下3点： 
+ 决定this的指向
+ 创建词法环境
+ 创建变量环境 


> ## 3. 词法环境

词法环境分为两大类： 全局环境和函数环境

> ## 4. 变量环境

变量环境也是一个词法环境，但不同的是词法环境被用来存储函数声明和变量（let 和 const）绑定，而变量环境只用来存储 var 变量绑定。


## 上面代码执行过程复盘：

1. 已经声明的变量name和函数say , 被存入内存堆中；
2. 调用say方法时，创建全局执行上下文；
3. 创建say函数的执行上下文；
4. 创建say函数体内的play函数执行上下文；
5. 开始执行： 将上下文中的变量赋值，执行代码， 栈顶的play函数执行完毕后弹出，接着执行say函数，完毕后弹出；


------
 this 是怎么被绑定的？

 作用域链是怎么形成的？

可执行上下文中的词法环境中含有外部词法环境的引用，我们可以通过这个引用获取外部词法环境的变量、声明等，这些引用串联起来一直指向全局的词法环境，因此形成了作用域链。

 闭包是怎么形成的？

可执行上下文中的词法环境中含有外部词法环境的引用，我们可以通过这个引用获取外部词法环境的变量、声明等，因此形成了闭包。