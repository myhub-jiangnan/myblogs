# JavaScript执行机制


 1. 执行上下文
 
   js 引擎执行代码的时候，先创建一个**全局执行上下文**，自动生成一个VO对象
   
   (览器环境中，OV对象就是指向window， node 环境 中就是指向GlobalObject。),

 在全局执行环境中, 进行预编译， 把一些已经声明的数据挂载到这个OV对象上， 这个过程也就是所谓的**变量提升**。

完成这些初始化工作后，就开始单线程的执行我们写的代码。遇到变量就从OV对象上找,有就读取，没有就返回引用错误。

执行函数的时候，在执行函数体里的代码前，先生成一个**函数执行上下文**，并且也会创建一个当前活动对象VO,把函数体内的

一些变量挂载到VO上,完成变量的提升，并且还会确定this的指向。函数体里的数据不可被外部访问，这就形成了**作用域**的概念。

函数的层层嵌套，作用域的由大到小，也就构成了作用域链的概念，沿着**作用域链**只能向上访问，即内部函数可以访问外部函数

作用域中的变量和参数，但外部函数不能访问内容函数中的数据。这样就保证了数据的有序访问和变量命名冲突的问题。函数执行完了，

内部的变量就会被自动销毁。这种变量使用完了就会被自动销毁又会带来一个问题，比如调用函数对变量A进行处理,处理完了我们

对外返回这个A,这样外部就可以使用A,不过A还是被销毁了。我们每次调用函数,都是一个新的变量A,处理的结果也都一样。而我们

先要做的效果是，每次调用函数，都是在之前的基础上，接着对A 进行操作, 这就要求A 不能被销毁。这里就要用到**闭包**。内部函

数引用了外部函数中的变量，就形成了闭包。这个内部函数就是闭包函数。闭包保存着外部函数的引用，就会导致外部函数执行

完了，被引用的变量无法销毁。 所以我们可以通过闭包返回这个变量，这样既保持了数据的私密性，又可以被外部使用，反复调用

该函数，都是在之前的基础上，继续进行操作。




> ## 1. JS 引擎(V8)

v8引擎主要由两部分组成： 内存堆（内存分配地址的地方）, 调用栈（代码执行的地方）

执行阶段： 将JavaScript 代码分为一块块的，可执行代码块进行执行。

目前有3类代码块：全局代码块，函数代码块，eval() 代码块

```javascript
  
   var name = "jack"

   function say(name){
       console.log(name)
       function play(){
           console.log("paly")
       }
       play()
   }
   say(name)

```

拿上面的代码为例，执行过程： 上面的代码声明被存放在 内存堆中，当调用say 方法时， say方法就会被压入调用栈。 栈是一个基础的数据结构，遵循“先进后出”；
在代码块执行前，会创建一个执行上下文,作为代码块的基本执行环境；

前面提到过有3类代码块， 这3类代码块对应着3种执行上下文

> ## 2. 执行上下文
在函数调用时，函数代码块执行之前，js 引擎会创建一个该函数的执行上下文；
执行上下文分为两个阶段： 创建阶段和执行阶段 

执行上下文的创建阶段主要解决以下3点： 
+ 决定this的指向
+ 创建词法环境
+ 创建变量环境 




## 上面代码执行过程复盘：

1. 已经声明的变量name和函数say , 被存入内存堆中；
2. 调用say方法时，创建全局执行上下文；
3. 创建say函数的执行上下文；
4. 创建say函数体内的play函数执行上下文；
5. 开始执行： 将上下文中的变量赋值，执行代码， 栈顶的play函数执行完毕后弹出，接着执行say函数，完毕后弹出；


