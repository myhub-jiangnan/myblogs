
# 闭包

> 定义：

 闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。

 词法环境是创建执行上下文时创建的。词法环境分为函数环境和全局环境。词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。 嵌套函数可访问声明于它们外部作用域的变量。


 因为执行上下文是在函数调用时创建，词法环境是在创建执行上下文是创建，所以，闭包也是在函数调用时才存在。

所谓闭包就是有权访问其他函数作用域中变量的函数 。通俗的定义就是嵌套在函数内部的函数。不必纠结怎样才算闭包，其实我们写的每一个函数都是闭包；


> 特点： 1. 函数嵌套函数 ；
        2. 内部函数可以访问外部函数中的变量；
        3. 参数和变量不会被回收；

> 闭包的作用：  

1.将函数内部和外部连接起来的桥梁 。函数内部的变量无法被外部访问，但是可以被闭包访问；
                    

2. 可以让局部变量模拟全局变量： 
        全局变量可能会带来命名冲突问题；
        变量最好私有化， 当我们想让局部变量发挥全局变量的作用时，可以考虑使用闭包。


> js中什么是垃圾回收 ？

答：js 引擎可以保证 内存空间中存放的某个数据没用时，就把这个分配的内存空间释放出来。该机制叫做垃圾回收。

> 为什么闭包会带来内存泄漏问题？ 

答：局部变量在函数退出时销毁， 但是如果被 闭包引用了，那么这个局部变量就能一直生存下去。
js 引擎分配的内存空间就无法释放出来，这块内存空间一直被占用着，我们就称之为内存泄漏；


> 为什么闭包只能取得包含函数中任何变量的最后一个值？

eg：如下所示：


 function createFunctions () {
    var result = new Array();
    
    for (var i = 0; i < 10; i++) {
        result[i] = function () {
            return i;
        }
    }    
    return result;
}

<!-- --------------------- 打印数组---------------------------- --> -->

var funcs = createFunctions();

for(var i=0;i<funcs.length;i++){

    console.log(funcs[i]);

}

打印result数组 ，结果全是 10  ；

原因： 
这个问题实质上是一个有关函数调用时机的问题， 只是被打上了”闭包的标签“ ；

1. 仅仅是声明某个函数，js 引擎并不会对函数内部的任何变量进行任何的 查找和赋值操作。 只会对函数内部的语法错误进行检查（如果有非法语句，即使不调用也会报错。）

   证明方法：  resuldt[i] = function(){
             reture j  ;

 }

// 虽然 j 没有被定义， 但是不会报错， 因为调用了  createFunctions ()时， 里面的闭包 还未被调用，　只是声明了函数，放进数组result里；

result[0](1);  // 如果调用result中的某个元素，才会报错。

2.  对循环语句里的那段代码理解错误：

  误以为：  result[0]= function(){result 0;}
         result[1]= function(){result 1;}
        result[2]= function(){result 2;}

 实际上：  
          result[0]= function(){result i;}
         result[1]= function(){result ;}
        result[2]= function(){result ;}

数组里的 i  和函数里的i 其实并不是一回事； 数组里的是常量；
函数里的是变量；
当我们调用 result[0]函数时，这个函数执行到 reture 语句时， 发现闭包里没有 变量 i, 于是顺着作用域链 向外寻找，createFunction（）里， i已经变成了１０　，这个过程才是闭包寻找变量的过程，跟闭包有关；

add5 和add10 都是闭包；makeAdder（） 是一个工厂函数 ，返回一个闭包；

---------



#   作用域

> 作用域分全局作用域，函数作用域，还有块级作用域。 作用域是静态的，在函数定义时生成。它决定了变量可以被访问的范围; 


