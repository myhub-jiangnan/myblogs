# 如何实现深拷贝？

浅拷贝和深拷贝，其实考察的是对基本数据类型和引用数据类型的理解。

一个变量如果保存的是基本数据类型，那么就无所谓深拷贝浅拷贝，因为该变量保存的就是该基本数据类型的数据的值本身。

一个变量如果保存的是引用数据类型，这时就要考虑深浅拷贝。因为该变量本质上保存的是该引用类型数据，在堆内存中的地址。

只拷贝这个引用数据类型在堆内存中的地址，就是所谓的浅拷贝。 完全拷贝这个引用数据类型的所有属性和属性值，就是所谓的深拷贝。

# 浅拷贝和深拷贝的影响

假如变量 a 保存的是一个引用数据类型， let b = a 这样则实现了浅拷贝。 当 a 的值被修改了时，b 的值也同样就被修改了，这就是浅拷贝的影响。

如果 b 对 a 实现了深拷贝，当 a 的值被修改了，b 的值还是 a 被修改前的值，这就是深拷贝的作用、

### 如何实现深拷贝

```

let oldData = {
    name:"jack",
    hobby:["swim","eat",{age:"16"}],
    fn(){
        console.log(this.name)
    }

}

// 写一个实现深拷贝的方法

function deepClone(oldData){

   // 先判断要拷贝的数据的数据类型,如果是函数或者null，直接返回
    if(typeof oldData !=== "object" || oldData ==null){

        return oldData    // 拷贝函数后，我们再修改这个函数，相当于重新写了这个函数，另外开辟另一个空间，不影响原来的函数
    }else{

        // 如果是对象类型，或者数组类型，就进行深拷贝 -->

        // 继续判断是对象还是数组, 分别声明一个空数组或者对象

        let res = Array.isArray(oldData)?[]:{}

        for(let k in oldData){

            // 只拷贝自身有的属性，不拷贝原型对象上的属性 ，for-in 循环还会遍历它原型链上的属性

            if(oldData.hasOwnProperty(k)){ // hasOwnProperty返回一个布尔值，检测对象中是否有指定的属性或者键

                res[k] = deepClone(oldData[k])

            }
        }
        return res

    }


}


```

小知识点：

1.typeof 返回数据类型的字符串， 但是要注意，判断的基本数据类型时，除了 null 返回 Oject，其他的基本数据类型都返回该基本数据类型的字符串。判断引用类型的数据时， 除了函数返回 function，对象和数组都返回 object

2. for...in 循环可以遍历对象和数组，遍历对象时还会遍历对象原型链上的属性。

3. hasOwnProperty 返回布尔值，判断对象中是否有指定的属性，判断数组是否有指定的键。
