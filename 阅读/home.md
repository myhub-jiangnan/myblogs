
# 《JavaScript 悟道》


## 1. 数值字面量

> 数值字面量本质上是一个对与该字面量真实值最接近的内置number对象的引用 


## 2. 对象

对象是一个键值对的集合，键名必须为字符串

## 3.  继承 

> Object.create()

## 4. weakMap

WeakMap 对象也是一组键值对的集合，但是键必须是对象


## 5. 语句

> JavaScript 有3种语句可以用来声明变量：let const function (var 已过时)

这3个关键字都可以用来声明变量

function语句 声明会创建一个function 对象，并用相应的变量代表它；

let语句 声明的变量不必是初始化，则该变量值为undefined;

const语句 声明的常量必须初始化，否则报错


## 6. 表达式
  
    JavaScript 允许语句的位置写任何表达式；表达式语句是所有语句种唯一不以关键字开头的语句。
    
  
> 有意义的表达式其实只有3类： 赋值 ，调用 和 delete 

#### 1. 不建议使用自增或者自减运算符 ++ 和--

这两个运算符早期设计出来是为了操作指针的。操作指针利大于弊，很多现在语言已经不
允许开发者直接操作它们 了。 现在他们的主要作用是给某个值加或者减1，没必要为此
设置一个特殊的语法；

## 7. 分支语句：if 和switch

不建议使用switch,, if完全可以实现switch的所有逻辑，且写的更紧凑。

switch语句会提供一个隐式的switch变量，会有导致错误的风险。而且书写风格上还有对齐与缩进的问题。

## 8. 循环语句

> 3种循环语句：for ,while和do..while

不建议使用 for 语句， 处理数组时，我们应当尽量使用forEach 方法来替代for语句;
对数组种的每一个元素，执行一次给定的函数;
for 语句要设置初始值，条件，增量。

```
  let arr = [1,2,3,4,5]
  
  arr.forEach(item=>{
      console.log(item)
  })


```

> while 语句

```
  let n = 10;
  while(n>0){
      n=n-1; 
  }
```

> do...while 语句

do...while 和while 的唯一区别就是判断条件的前置和后置

```
 let n =10;
 
 do{
     n= n-1
 }while(n>0)
 

```

## > 建议将条件判断放中间

```
  let n= 10;
  while(true){
      if(n>0){
          n=n-1
      }
  }

```

## 9. 中断语句

> 4种中断语句： break，continue,throw 和return;

break 语句用于退出循环；

continue 用于跳到循环语句的顶部；

throw 语句用于抛出异常；

return 用于**中断函数的运行并返回值**

## 10. 函数

> 函数对象有两个隐藏的属性

#### a. 当前函数可执行代码的引用

#### b. 当函数执行时，这个函数对应的活动对象(VO)就被激活了，从而为闭包提供了可能性。函数可以通过这个隐藏属性去访问函数中创建的变量；

## 11. 闭包

>  拥有**外层函数**对应的**活动对象**的**引用**的**函数**，就被称为**闭包**

**通俗解释：** 在一个函数中创建另一个函数，内部函数引用了外部函数中的变量，这个时候内部函数就拥有了外部函数对应的活动对象的引用，这个内部函数就是闭包。

### 离开闭包，JavaScript 就没有了灵魂。


## 12. 异常

JavaScript 异常处理借鉴于Java,Java 的异常处理借鉴于C++,而C++ 是一门没有现代化内存处理的语言.

JavaScript 中用throw 抛出任意类型的值；

>try...catch

```
   try{
       // tru 语句中包含可能有异常的代码
   }catch(error){
       // try 中如果有异常，则通过throw 抛出，JavaScript 就会执行catch中的代码，
       throw 抛出的内容就是cathc 的参数；
   }
  
```

## 13. 模块变量

#### 历史背景

早期JavaScript 作为网页的脚本语言，是结合<script></script> 标签来使用并执行的。
由于其语言系统简单，JavaScript引擎直接被嵌入到了所有现代浏览器中。这样在html 页面中把JavaScript 代码写在<script></script>标签中间，JavaScript源代码就直接可以在浏览器中被解释执行。

每个**scirpt 标签包含的代码**被称为JavaScript**脚本块**，相近的功能代码就放在一个脚本块中。一个脚本块儿，是一个**源码单位**，JavaScript 引擎是按源码单位进行分发的。

随着JavaScript 能处理的问题越来越多，代码量越来越多。**带来很多问题**。

> 比如每个脚本块中函数外声明的变量，都会添加**页面级别**的作用域中，即全局作用域中，变成全局变量。而**全局变量**对该页面中的所有**源码单位** 可见。 这会带来严重的**变量污染**问题。



#### 模块

在这个背景下，模块的概念应运而生。 有了模块，每个模块中的数据都是相互独立的，互不影响。函数外声明的变量只会添加到
模块级别的作用域中，只对当前模块总的函数可见。 **模块之间如果想要进行数据交换**，就通过**import** 和**export**语句进行数据的导出和引用。


#### 一个.js 文件就是一个模块。一个html 页面引用多个js模块。


微观层面的优秀程序取决于良好的**编码约定**。

宏观层面的优秀程序取决于良好的**模块设计**


## 14. this

**this 是函数在被调用执行时才在该函数内部自动生成的一个引用，这个引用指向调用该函数的对象。**

所以this有两个重要特征：**动态生成**和**动态绑定**；这是this 使用容易造成混乱的根源。

**在方法调用中，this会指向对应的对象。在函数调用中，this就会被绑定到全局对象上。**



 
 #### 应用场景

如果相似的对象都有相似的方法，则将所有的方法挂载到同一个共享原型对象上比把它们在每个对象上挂载一遍更节约内存空间。

**那么原型上的函数如何知道自己在执行的时候，是作用于哪个对象呢？这就要用到this 了。**



调用一个对象的方法的时候，JavaScript会在对应的对象及其**原型链**上搜索对应的方法名。若存在，就直接用，不需要关心是从哪个原型对象上获取的。


```

   let person = {
            name: "jack",
            say() {
                console.log("我是原型对象");
                console.log(this);
                function inner_say() {
                    console.log("say的内部函数");
                    console.log(this);
                }
                inner_say()
            }
    }


    let p = Object.create(person)
        p.age = 20;
    p.write = function () {
            console.log("我是实例对象");
            console.log(this);
    }
    
    p.say()
    person.say()

```

p继承于person 对象，所以person 对象为p对象的原型对象；

#### a. 执行p.say()

 p 对象上没有say 方法，但是它的原型对象上有，所以可以拿来执行。
 
 第一个this 指向的是p对象，而非person对象，因为say()是被当作p对象的方法调用的，所以say()中的this 绑定的是p 对象。
 
 第二个this 指向的是全局对象window 。因为say中的inner_say()是被作为函数直接调用的，本质上是被作为window对象的方法来调用的，所以inner_say 里的this 指向的是window 对象。
 
 #### b. 执行person.say()
 
 第一个this 指向的是person 对象；
 第二个this 指向的也是window对象。
 
 





 
 

































































